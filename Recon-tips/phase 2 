
---

ðŸ” Phase 2: Stack-Aware Recon (Layered Discovery using Tech Awareness)

> Goal: Now that you know the tech stack (via Wappalyzer etc.), start digging strategically. This phase is all about precision discovery, custom recon paths, and tech-matching exploits.




---

1. Build a Stack â†’ Attack Map

For each tech/framework, thereâ€™s a list of known misconfigurations, juicy endpoints, and common logic bugs.
Start mapping those now.

Examples:

React / Angular / Next.js

Check: client-side routing quirks (/#/admin, /dashboard)

Open redirects using query params (?next=, ?redirect=)

Hidden routes in JS files


WordPress / Laravel / PHP

Look for .env, .git, wp-json, /vendor, /storage

Run CMS-specific fingerprinting tools (wpscan, larascan)


Node.js / Express

Common misroutes, prototype pollution, file disclosure in dev mode


Firebase / AWS / GCP

Check for exposed keys, misconfigured .well-known/assetlinks.json, S3 leaks, IAM role assumptions




---

2. Smart Google Dorking (tech-specific)

Now that you know the backend or platform, you can use sniper dorks:

site:target.com inurl:.env
site:target.com intitle:"index of" "config"
site:github.com target.com language:json
site:target.com ext:js inurl:firebase

You're no longer guessing â€” you're using context from the tech stack.


---

3. Hidden Endpoints & Soft 403 Bypasses

Most modern web apps donâ€™t give 404. They give:

403 â†’ forbidden

401 â†’ unauthorized

200 â†’ soft redirects

500 â†’ crash indicators


You want to test things like:

/admin
/admin/
/admin%2f
/..;/admin
/;admin

Tools: ffuf, feroxbuster, or mobile-friendly ones like arjun (for parameter discovery).

> But only after you logically guess based on the stack. Example: Laravel? Try /artisan, /storage/logs, /debugbar.




---

4. GitHub Recon â€” But Targeted

Since you know the target uses React or Laravel or Firebase, look for devs or orgs uploading:

"target.com" filename:firebase.json
"target.com" language:javascript "apiKey"
"target.com" language:env

Save and analyze .env, config.js, .yml, docker-compose.yml


---

5. Behavioral Mapping

Use the stack knowledge to test how the app behaves when something goes wrong.

Examples:

React + REST API:

Send invalid tokens or requests, observe error structure.


Laravel:

Add _debug param to URL, see if debug bar activates.


Firebase:

Test if https://<project>.firebaseio.com/.json exposes data



Behavior tells you whatâ€™s enabled, even when itâ€™s hidden.


---

6. Tag Everything in Your Recon Notes

Use this structure for notes:

## Laravel Recon Notes
- Tech Confirmed via: X-Powered-By header
- Common Laravel files: .env, /storage/logs, /vendor
- Actions Taken:
  - Dorked for exposed `.env` âœ…
  - Hit known paths (`/artisan`, `/server.php`) âœ…
  - Analyzed headers: `APP_ENV=production` found

## Firebase Recon Notes
- Found firebaseConfig in main.js
- Tried public `.json` access â€” denied âœ…
- Tested for storage bucket access â€” denied âœ…
- Note: Watch for mobile apps using this config


---

7. Bonus: Build Recon Trees per Stack

Once you do this for 5â€“6 different stacks, you can reuse recon trees.

Example:

React Tree â†’
  - Gather JS â†’ Parse Endpoints
  - Test client routes â†’ /#/admin
  - Look for exposed props/state in console
  - Look for token in localStorage/sessionStorage


---

ðŸŽ¯ Whatâ€™s the Real Goal of Phase 2?

Not just finding paths â€” but understanding the recon patterns of each tech stack.
Once you do this across targets, youâ€™ll develop:

Recon intuition: Youâ€™ll guess bugs just from stack

Less noise: No more bruteforcing junk

More signal: Straight to juicy, real bugs



---